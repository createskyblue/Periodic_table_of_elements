#include <Arduboy2.h>
#include "Font3x5.h"
Arduboy2 arduboy;
Font3x5 tinyfont = Font3x5();
/*=========================================================
                         位图
  =========================================================*/
//HWT
const uint8_t HWT[] PROGMEM = {0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x06, 0x33, 0x3c, 0x12, 0x8b, 0xe0, 0x89, 0x44, 0x42, 0x09, 0x49, 0x24, 0x12, 0x88, 0x80, 0x89, 0x44, 0x99, 0x02, 0x49, 0x3c, 0x1e, 0x88, 0x8c, 0x8f, 0x44, 0x99, 0x04, 0x49, 0x24, 0x12, 0xa8, 0x8c, 0x89, 0x54, 0x42, 0x08, 0x49, 0x24, 0x12, 0x50, 0x80, 0x89, 0x28, 0x66, 0x0f, 0x33, 0xbc, 0x12, 0x50, 0x80, 0xe9, 0x28, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
//title
const uint8_t title[] PROGMEM = {0x00, 0x00, 0x00, 0x08, 0x00, 0x3f, 0xff, 0x02, 0x30, 0x00, 0x00, 0x80, 0x00, 0x3f, 0xfc, 0x03, 0xff, 0xf0, 0x3f, 0xff, 0x02, 0x33, 0xf8, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x30, 0x83, 0x0f, 0xfb, 0x18, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x30, 0x83, 0x07, 0x33, 0x18, 0x00, 0x80, 0x00, 0x00, 0x00, 0x03, 0xff, 0xe0, 0x37, 0xf3, 0x02, 0x33, 0x18, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x30, 0x83, 0x03, 0xf3, 0xf8, 0x3f, 0xfe, 0x00, 0x7f, 0xff, 0x0f, 0xff, 0xf8, 0x21, 0xc3, 0x02, 0x33, 0x18, 0x00, 0x80, 0x00, 0x06, 0x20, 0x00, 0x31, 0x80, 0x2f, 0xfb, 0x03, 0x33, 0x18, 0xff, 0xff, 0x80, 0x06, 0x20, 0x01, 0xff, 0x80, 0x20, 0x03, 0x03, 0xf3, 0x18, 0x03, 0x40, 0x00, 0x06, 0x20, 0x01, 0xfe, 0x40, 0x27, 0xf3, 0x02, 0x33, 0xf8, 0x06, 0xc2, 0x00, 0x06, 0x20, 0x00, 0x38, 0x60, 0x26, 0x33, 0x0f, 0xfb, 0x18, 0x0e, 0x46, 0x00, 0x04, 0x20, 0x03, 0xff, 0xf0, 0x66, 0x33, 0x0f, 0xfb, 0x18, 0x3e, 0x7c, 0x00, 0x0c, 0x20, 0x03, 0x0c, 0x00, 0x66, 0x33, 0x02, 0x23, 0x18, 0x76, 0x38, 0x00, 0x18, 0x21, 0x80, 0xcc, 0xc0, 0x67, 0xf3, 0x06, 0x36, 0x18, 0x46, 0xd8, 0x00, 0x38, 0x31, 0x87, 0x8c, 0x70, 0x40, 0x03, 0x0c, 0x1e, 0x18, 0x07, 0x8f, 0x80, 0xf0, 0x3f, 0x06, 0x3c, 0x30, 0xc0, 0x1f, 0x08, 0x0c, 0x38, 0x07, 0x03, 0x80, 0x40, 0x00, 0x00, 0x10, 0x00, 0x40, 0x0e, 0x00, 0x00, 0x20, 0x04, 0x00, 0x00};
const uint8_t L[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x03, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x03, 0x70, 0x3F, 0x87, 0xF0, 0xC1, 0x99, 0x83,
  0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x07, 0x30, 0x3F, 0xC7, 0xF8, 0xC1, 0x99, 0xC3,
  0x1F, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x06, 0x38, 0x30, 0xC6, 0x1C, 0xC1, 0x99, 0xE3,
  0x18, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0E, 0x18, 0x30, 0xC6, 0x0C, 0xC1, 0x99, 0xF3,
  0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0F, 0xFC, 0x3F, 0xC6, 0x0C, 0xC1, 0x99, 0xBB,
  0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x1F, 0xFC, 0x3F, 0x06, 0x0C, 0xC1, 0x99, 0x9F,
  0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x18, 0x0E, 0x31, 0x86, 0x1C, 0xE3, 0x99, 0x8F,
  0x38, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x38, 0x07, 0x30, 0xC7, 0xF8, 0x7F, 0x19, 0x87,
  0x1F, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x78, 0x07, 0xB0, 0xE7, 0xE0, 0x3E, 0x19, 0x87,
  0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x00, 0x10,
  0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x04, 0x92, 0x00, 0x08,
  0x00, 0x00, 0x20, 0x40, 0x80, 0x3E, 0x78, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x02, 0xA4, 0x01, 0xFF,
  0xE0, 0x7F, 0xC0, 0x40, 0x80, 0x24, 0x88, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x02, 0xC4, 0x02, 0x00,
  0x40, 0x00, 0x00, 0x08, 0x88, 0x24, 0x88, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0F, 0xF7, 0xE2, 0x00,
  0x80, 0x00, 0x00, 0x1F, 0xF8, 0x3C, 0x78, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0xCC, 0x81, 0xFF,
  0x80, 0x00, 0x19, 0xA8, 0x90, 0x26, 0xA0, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x02, 0xB4, 0x80, 0x02,
  0x03, 0xFF, 0xE0, 0xA8, 0x80, 0x03, 0x14, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x04, 0x94, 0x80, 0x04,
  0x00, 0x24, 0x00, 0x27, 0xF8, 0x7C, 0xE8, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x08, 0x84, 0x80, 0x0C,
  0x00, 0x24, 0x80, 0x4A, 0x10, 0x0C, 0x40, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x34, 0x87, 0xFF,
  0xF0, 0x44, 0x40, 0x49, 0x20, 0x10, 0x30, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x07, 0xE3, 0x00, 0x08,
  0x00, 0x44, 0x20, 0x49, 0x20, 0x7E, 0xFE, 0x00,
  0x00, 0x1E, 0x00, 0x00, 0x02, 0x43, 0x00, 0x08,
  0x00, 0x84, 0x10, 0x88, 0xC0, 0x22, 0x88, 0x00,
  0x00, 0x33, 0x00, 0x00, 0x01, 0xC3, 0x00, 0x08,
  0x01, 0x04, 0x10, 0x90, 0xC0, 0x22, 0x88, 0x00,
  0x00, 0x61, 0x80, 0x00, 0x01, 0xB4, 0x80, 0x08,
  0x02, 0x04, 0x00, 0x91, 0x30, 0x22, 0x88, 0x00,
  0x00, 0xC0, 0x80, 0x00, 0x02, 0x08, 0x60, 0x38,
  0x00, 0x1C, 0x00, 0xA6, 0x1C, 0x3E, 0xF8, 0x00,
  0x00, 0x80, 0xC0, 0x00, 0x04, 0x30, 0x00, 0x10,
  0x00, 0x08, 0x00, 0x58, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x80, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x60, 0x00, 0x20, 0x00, 0x18, 0x00, 0x00,
  0x06, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x06,
  0x00, 0x30, 0x00, 0x60, 0x00, 0x18, 0x00, 0x00,
  0x06, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x06,
  0x00, 0x30, 0x00, 0x60, 0x00, 0x18, 0x00, 0x00,
  0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x06,
  0x1E, 0x31, 0xBC, 0xFE, 0x38, 0xDB, 0xC1, 0xD8,
  0x04, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x0C,
  0x3F, 0x19, 0xFE, 0xFE, 0x38, 0xDF, 0xE3, 0xF8,
  0x04, 0x00, 0x18, 0x00, 0x10, 0x00, 0x00, 0x0C,
  0x73, 0x19, 0xC6, 0x63, 0x39, 0x9C, 0x67, 0x38,
  0x0C, 0x00, 0x18, 0x00, 0x18, 0x00, 0x00, 0x0C,
  0x60, 0x19, 0x86, 0x63, 0x6D, 0x98, 0x66, 0x18,
  0x7F, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x0C,
  0x60, 0x19, 0x86, 0x63, 0x6D, 0x98, 0x66, 0x18,
  0x0C, 0x00, 0x08, 0x00, 0x10, 0x00, 0x00, 0x0C,
  0x60, 0x19, 0x86, 0x63, 0x6D, 0x98, 0x66, 0x18,
  0x00, 0x00, 0x08, 0x00, 0x30, 0x00, 0x00, 0x0C,
  0x73, 0x19, 0x86, 0x61, 0xC7, 0x18, 0x67, 0x38,
  0x00, 0x00, 0x0C, 0x00, 0x30, 0x00, 0x00, 0x0C,
  0x3F, 0x19, 0x86, 0x79, 0xC7, 0x18, 0x63, 0xF8,
  0x00, 0x00, 0x0C, 0x00, 0x30, 0x00, 0x00, 0x06,
  0x1E, 0x31, 0x86, 0x39, 0xC7, 0x18, 0x61, 0xD8,
  0x00, 0x00, 0x04, 0x00, 0x20, 0x00, 0x00, 0x06,
  0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
  0x00, 0x00, 0x04, 0x00, 0x20, 0x00, 0x00, 0x06,
  0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
  0x00, 0x00, 0x06, 0x00, 0x60, 0x00, 0x00, 0x03,
  0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
  0x00, 0x00, 0x06, 0x00, 0x60, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x02, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x03, 0x00, 0xC0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x01, 0xC7, 0x04, 0x70, 0x38, 0xE0,
  0x00, 0x00, 0x03, 0x00, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x02, 0x28, 0x8C, 0x88, 0x45, 0x10,
  0x00, 0x00, 0x01, 0x01, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x28, 0x94, 0x08, 0x45, 0x10,
  0x00, 0x00, 0x01, 0x81, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x48, 0x84, 0x30, 0x44, 0xE0,
  0x00, 0x00, 0x00, 0xC3, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x88, 0x84, 0x08, 0x45, 0x10,
  0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x01, 0x08, 0x84, 0x88, 0x45, 0x10,
  0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x03, 0xE7, 0x04, 0x70, 0x38, 0xE0,
  0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
//放射性
const uint8_t radiation[] PROGMEM = {0x00, 0x00, 0x0f, 0xf0, 0x1f, 0xe8, 0x27, 0xe4, 0x43, 0xc2, 0x43, 0x82, 0x03, 0x80, 0x02, 0x40, 0x7e, 0x7e, 0x7f, 0xfe, 0x7c, 0x7e, 0x7c, 0x3e, 0x38, 0x1c, 0x18, 0x18, 0x0c, 0x30, 0x00, 0x00};
//金属
const uint8_t Bmrtal[] PROGMEM = {0x00, 0x00, 0x03, 0xfe, 0x04, 0x06, 0x08, 0x0a, 0x10, 0x12, 0x3f, 0xe2, 0x20, 0x22, 0x20, 0x22, 0x20, 0x22, 0x60, 0x22, 0xa0, 0x24, 0x60, 0x29, 0xa0, 0x3a, 0x7f, 0xf5, 0xaa, 0xaa, 0x55, 0x54};
const uint8_t Element[] PROGMEM = {0x7f, 0xc0, 0x10, 0x01, 0x00, 0x1c, 0x80, 0x00, 0x00, 0x10, 0x03, 0xfc, 0x38, 0x80, 0x00, 0x01, 0xff, 0x02, 0x08, 0x09, 0x98, 0x00, 0x00, 0x10, 0x0d, 0x90, 0x3f, 0x18, 0xff, 0xc3, 0xff, 0x80, 0xe0, 0x18, 0x40, 0x1a, 0x00, 0xfe, 0x00, 0xc0, 0x18, 0x40, 0x12, 0x00, 0x33, 0x03, 0xfc, 0x1d, 0x50, 0x12, 0x01, 0xff, 0x8f, 0x04, 0x39, 0x48, 0x32, 0x00, 0x10, 0x01, 0x04, 0x2b, 0x48, 0x63, 0x21, 0x93, 0x01, 0xfc, 0x0a, 0x40, 0xc1, 0xe2, 0x30, 0x01, 0x04, 0x08, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
//元素名称
const uint8_t Relative[] PROGMEM = {0x7f, 0xe1, 0xff, 0x04, 0x40, 0x0b, 0xf0, 0x42, 0x00, 0x06, 0x06, 0x4c, 0x10, 0x30, 0x5f, 0xc0, 0x08, 0x02, 0x58, 0x34, 0x20, 0x50, 0x40, 0x10, 0x00, 0x40, 0x0c, 0xe0, 0x5f, 0xc0, 0x10, 0x0f, 0xfe, 0x1b, 0x18, 0x50, 0x43, 0xff, 0x80, 0x40, 0x3a, 0x00, 0x5f, 0xc0, 0x10, 0x00, 0x40, 0x2b, 0xf8, 0x42, 0x00, 0x10, 0x0f, 0xfe, 0x08, 0x40, 0x4a, 0xc0, 0x10, 0x00, 0x40, 0x08, 0x40, 0x92, 0x60, 0x10, 0x00, 0x40, 0x08, 0x40, 0xa6, 0x00, 0x70, 0x00, 0x40, 0x1f, 0xf8};
//相对质量
const uint8_t RM[] PROGMEM = {0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xf0, 0x00, 0x81, 0xfe, 0x0f, 0xf8, 0x12, 0x11, 0xf0, 0x83, 0xb0, 0x0f, 0xf8, 0x7e, 0x10, 0x3f, 0xc3, 0xff, 0x0f, 0xf8, 0x33, 0xf0, 0x37, 0xc3, 0xfe, 0x18, 0x0c, 0x33, 0x11, 0xa0, 0x82, 0x30, 0x1f, 0xfc, 0x3e, 0x10, 0xec, 0x82, 0xfe, 0x0f, 0xf8, 0x77, 0xf0, 0x64, 0x82, 0x92, 0x0f, 0xf8, 0x52, 0x10, 0x64, 0x82, 0x92, 0x0f, 0xf8, 0x12, 0x10, 0xb0, 0x86, 0x3c, 0x00, 0x80, 0x13, 0xf1, 0x90, 0x86, 0x6e, 0x07, 0xf0, 0x13, 0x11, 0x03, 0x85, 0xc3, 0x1f, 0xfc};
//价态
const uint8_t VA[] PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x08, 0x01, 0xfc, 0x04, 0x38, 0x11, 0x80, 0x18, 0x00, 0x1f, 0xc1, 0xff, 0xc1, 0xfc, 0x09, 0xa0, 0x11, 0x81, 0xff, 0xc0, 0x10, 0x40, 0x7f, 0x01, 0x04, 0x09, 0x20, 0x22, 0x40, 0x14, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x19, 0x20, 0x26, 0x30, 0x22, 0x00, 0x7f, 0xf0, 0x7f, 0x07, 0xff, 0x19, 0xfc, 0x6c, 0x10, 0x73, 0x00, 0x24, 0x00, 0x00, 0x02, 0x40, 0x09, 0x20, 0x22, 0x41, 0x88, 0xc0, 0x3f, 0xe1, 0x00, 0x43, 0xfe, 0x09, 0x20, 0x22, 0x41, 0x00, 0x00, 0x3d, 0x41, 0x3e, 0x43, 0xd4, 0x09, 0x30, 0x22, 0x40, 0xac, 0x80, 0x26, 0xc1, 0x22, 0x42, 0x6c, 0x09, 0xd0, 0x22, 0x41, 0xa0, 0xc0, 0x7c, 0xc1, 0x3e, 0x47, 0xcc, 0x09, 0xdc, 0x24, 0x41, 0x21, 0x40, 0x05, 0x31, 0x00, 0xc0, 0x53, 0x08, 0x4c, 0x2c, 0x40, 0x3f, 0x00};
const uint8_t BootA[] PROGMEM = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x03, 0xca, 0x80, 0x00, 0x03, 0xca, 0x80, 0x00, 0x03, 0xcb, 0xc0, 0x00, 0x03, 0xc8, 0x80, 0x00, 0x03, 0xc8, 0x80, 0x00, 0x03, 0xc8, 0x80, 0x00, 0x03, 0xc0, 0x07, 0xd8, 0x03, 0xc0, 0x1c, 0xd8, 0x03, 0xc0, 0x1c, 0x00, 0x03, 0xc0, 0x1c, 0x18, 0x03, 0xc0, 0x0e, 0x18, 0x03, 0xc0, 0x07, 0x98, 0x03, 0xc0, 0x01, 0xd8, 0x03, 0xc0, 0x00, 0xd8, 0x03, 0xc0, 0x1c, 0xd8, 0x03, 0xc0, 0x0f, 0x98, 0x03, 0xc0, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x03, 0xc1, 0x9c, 0x77, 0x03, 0xc2, 0x44, 0x55, 0x03, 0xc0, 0x9c, 0x57, 0x03, 0xc1, 0x04, 0x51, 0x03, 0xc3, 0xdd, 0x77, 0x03, 0xc0, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
const uint8_t BootB[] PROGMEM = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x03, 0xc0, 0x38, 0x00, 0x03, 0xc0, 0x44, 0x00, 0x03, 0xc0, 0x82, 0x00, 0x03, 0xc0, 0x82, 0x00, 0x03, 0xc1, 0x01, 0x00, 0x03, 0xc1, 0x01, 0x00, 0x03, 0xc1, 0x01, 0x00, 0x03, 0xcf, 0xff, 0xff, 0xe3, 0xc0, 0x01, 0x01, 0x03, 0xc0, 0x01, 0x01, 0x03, 0xc0, 0x01, 0x01, 0x03, 0xc0, 0x00, 0x82, 0x03, 0xc0, 0x00, 0x82, 0x03, 0xc0, 0x00, 0x44, 0x03, 0xc0, 0x00, 0x38, 0x03, 0xc0, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x80, 0x03, 0xcf, 0xcb, 0xeb, 0x43, 0xc0, 0x00, 0xaf, 0xc3, 0xdf, 0xef, 0xdf, 0xc3, 0xc1, 0x03, 0x47, 0x83, 0xc9, 0x4d, 0xdc, 0xe3, 0xd9, 0x3d, 0x83, 0x03, 0xc7, 0x1f, 0x6f, 0xc3, 0xc0, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

const uint8_t rook_bitmap5[] PROGMEM = {
  0x0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0x0, 0x0
};//电池满
const uint8_t rook_bitmap4[] PROGMEM = {
  0x0, 0xFE, 0xFB, 0xF9, 0xFB, 0xFE, 0x0, 0x0
};
const uint8_t rook_bitmap3[] PROGMEM = {
  0x0, 0xFE, 0xF3, 0xF1, 0xF3, 0xFE, 0x0, 0x0
};
const uint8_t rook_bitmap2[] PROGMEM = {
  0x0, 0xFE, 0xE3, 0xE1, 0xE3, 0xFE, 0x0, 0x0
};
const uint8_t rook_bitmap1[] PROGMEM = {
  0x0, 0xFE, 0xC3, 0xC1, 0xC3, 0xFE, 0x0, 0x0
};
const uint8_t rook_bitmap0[] PROGMEM = {
  0x0, 0xFE, 0x83, 0x81, 0x83, 0xFE, 0x0, 0x0
}; //电池空
/*=========================================================
                         变量
  =========================================================*/
//元素周期表
bool flash = 0;  //电池闪烁警告位置
int TEIRN = 0; //彩蛋计数
boolean metal;
boolean refresh = true;
byte EX = 0;
byte EY = 0; //当前显示位置
int Nx, Ny;
byte ZQ; //周期
const  byte AM[10][18] PROGMEM = {  //排列方式
  {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2},
  {3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 6, 7, 8, 9, 10},
  {11, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 14, 15, 16, 17, 18},
  {19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36},
  {37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54},
  {55, 56, 0, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86},
  {87, 88, 0, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 0, 0},
  {0, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 0, 0}
};
const byte non[24] PROGMEM = {  //非金属
  1, 2,
  5, 6, 7, 8, 9, 10,
  14, 15, 16, 17, 18,
  33, 34, 33, 36,
  52, 53, 54,
  85, 86,
  117, 118,
};
const byte Radius[107] PROGMEM = {  //半径
  78, 100, 154, 113, 95, 86, 80, 66, 64, 100,
  191, 160, 143, 134, 130, 104, 162, 100, 234, 197, 164,
  145, 135, 127, 132, 127, 126, 124, 128, 139, 140, 140,
  150, 160, 111, 114, 250, 215, 180, 160, 148, 140, 135,
  132, 134, 137, 144, 157, 166, 158, 160, 170, 195, 133,
  271, 224, 184, 182, 183, 182, 163, 180, 204, 180, 178,
  177, 177, 176, 175, 194, 173, 159, 148, 141, 146, 134,
  136, 139, 144, 162, 173, 175, 170, 170, 153, 153, 153,
  153, 188, 180, 160, 155, 158, 164, 173, 142, 142, 142,
  142, 142, 142, 142, 142, 142, 142, 142, 142,
};
const byte mass[] PROGMEM = {  //相对质量
  10, 8, 40, 3, 69, 41, 90, 12, 10, 81, 12, 1, 14, 1,
  16, 0, 19, 00, 20, 18, 22, 99, 24, 31, 26, 98, 23, 9,
  30, 97, 32, 6, 35, 45, 39, 95, 39, 10, 40, 8, 44, 96,
  47, 87, 50, 94, 52, 0, 54, 94, 55, 85, 58, 93, 58, 69,
  63, 55, 65, 38, 69, 72, 72, 63, 74, 92, 78, 96, 79, 90,
  83, 80, 85, 47, 87, 62, 88, 91, 91, 22, 92, 91, 95, 96,
  98, 0, 10, 11, 10, 29, 10, 64, 10, 79, 11, 24, 11, 48,
  11, 87, 12, 18, 12, 76, 12, 69, 13, 13, 13, 29, 13, 73,
  13, 89, 14, 1, 14, 9, 14, 42, 14, 50, 15, 4, 15, 20,
  15, 73, 15, 89, 16, 25, 16, 49, 16, 73, 16, 89, 17, 31,
  17, 50, 17, 85, 18, 9, 18, 38, 18, 62, 19, 2, 19, 22,
  19, 51, 19, 70, 20, 6, 20, 44, 20, 72, 20, 90, 20, 90,
  21, 0, 22, 20, 22, 30, 22, 60, 22, 70, 23, 20, 23, 10,
  23, 80, 23, 70, 24, 40, 24, 30, 24, 70, 24, 70, 25, 10,
  25, 20, 25, 70, 25, 80, 25, 90, 26, 20, 26, 50, 26, 80,
  27, 10, 27, 00, 27, 70, 27, 60, 28, 10, 28, 00, 28, 50,
  28, 40, 28, 90, 28, 80, 29, 30, 29, 40, 29, 40, 30,
};
const  byte AC[118][7] PROGMEM = {  //结构
  {1, 0, 0, 0, 0, 0, 0},
  {2, 0, 0, 0, 0, 0, 0},
  {2, 1, 0, 0, 0, 0, 0},
  {2, 2, 0, 0, 0, 0, 0},
  {2, 3, 0, 0, 0, 0, 0},
  {2, 4, 0, 0, 0, 0, 0},
  {2, 5, 0, 0, 0, 0, 0},
  {2, 6, 0, 0, 0, 0, 0},
  {2, 7, 0, 0, 0, 0, 0},
  {2, 8, 0, 0, 0, 0, 0},
  {2, 8, 1, 0, 0, 0, 0},
  {2, 8, 2, 0, 0, 0, 0},
  {2, 8, 3, 0, 0, 0, 0},
  {2, 8, 4, 0, 0, 0, 0},
  {2, 8, 5, 0, 0, 0, 0},
  {2, 8, 6, 0, 0, 0, 0},
  {2, 8, 7, 0, 0, 0, 0},
  {2, 8, 8, 0, 0, 0, 0}, //18
  {2 , 8 , 8 , 1, 0, 0, 0},
  {2 , 8 , 8 , 2, 0, 0, 0},
  {2 , 8 , 9 , 2, 0, 0, 0},
  {2 , 8 , 10 , 2, 0, 0, 0},
  {2 , 8 , 11 , 2, 0, 0, 0},
  {2 , 8 , 13 , 1, 0, 0, 0},
  {2 , 8 , 13 , 2, 0, 0, 0},
  {2 , 8 , 14 , 2, 0, 0, 0},
  {2 , 8 , 15 , 2, 0, 0, 0},
  {2 , 8 , 16 , 2, 0, 0, 0},
  {2 , 8 , 18 , 1, 0, 0, 0},
  {2 , 8 , 18 , 2, 0, 0, 0},
  {2 , 8 , 18 , 3, 0, 0, 0},
  {2 , 8 , 18 , 4, 0, 0, 0},
  {2 , 8 , 18 , 5, 0, 0, 0},
  {2 , 8 , 18 , 6, 0, 0, 0},
  {2 , 8 , 18 , 7, 0, 0, 0},
  {2 , 8 , 18 , 8, 0, 0, 0,},
  {2 , 8 , 18 , 8 , 1, 0, 0},
  {2 , 8 , 18 , 8 , 2, 0, 0},
  {2 , 8 , 18 , 9 , 2, 0, 0},
  {2 , 8 , 18 , 10, 2, 0, 0},
  {2 , 8 , 18 , 12, 1, 0, 0},
  {2 , 8 , 18 , 13, 1, 0, 0},
  {2 , 8 , 18 , 13, 2, 0, 0},
  {2 , 8 , 18 , 15, 1, 0, 0},
  {2 , 8 , 18 , 16, 1, 0, 0},
  {2 , 8 , 18 , 18 , 0, 0, 0},
  {2 , 8 , 18 , 18 , 1 , 0, 0},
  {2 , 8 , 18 , 18 , 2 , 0, 0},
  {2 , 8 , 18 , 18 , 3 , 0, 0},
  {2 , 8 , 18 , 18 , 4 , 0, 0},
  {2 , 8 , 18 , 18 , 5 , 0, 0},
  {2 , 8 , 18 , 18 , 6 , 0, 0},
  {2 , 8 , 18 , 18 , 7 , 0, 0},
  {2 , 8 , 18 , 18 , 8 , 0, 0},
  {2 , 8 , 18 , 18 , 8 , 1, 0},
  {2 , 8 , 18 , 18 , 8 , 2, 0},
  {2 , 8 , 18 , 18 , 9 , 2, 0},
  {2 , 8 , 18 , 19 , 9 , 2, 0},
  {2 , 8 , 18 , 21 , 8 , 2, 0},
  {2 , 8 , 18 , 22 , 8 , 2, 0},
  {2 , 8 , 18 , 23 , 8 , 2, 0},
  {2 , 8 , 18 , 24 , 8 , 2, 0},
  {2 , 8 , 18 , 25 , 8 , 2, 0},
  {2 , 8 , 18 , 25 , 9 , 2, 0},
  {2 , 8 , 18 , 27 , 8 , 2, 0},
  {2 , 8 , 18 , 28 , 8 , 2, 0},
  {2 , 8 , 18 , 29 , 8 , 2, 0},
  {2 , 8 , 18 , 30 , 8 , 2, 0},
  {2 , 8 , 18 , 31 , 8 , 2, 0},
  {2 , 8 , 18 , 32 , 8 , 2, 0},
  {2 , 8 , 18 , 32 , 9 , 2, 0},
  {2 , 8 , 18 , 32 , 10, 2, 0}, //72
  {2 , 8 , 18 , 32 , 11, 2 , 0},
  {2 , 8 , 18 , 32 , 12, 2 , 0},
  {2 , 8 , 18 , 32 , 13, 2 , 0},
  {2 , 8 , 18 , 32 , 14, 2 , 0},
  {2 , 8 , 18 , 32 , 15, 2 , 0},
  {2 , 8 , 18 , 32 , 17, 1 , 0},
  {2 , 8 , 18 , 32 , 18, 1 , 0},
  {2 , 8 , 18 , 32 , 18, 2 , 0},
  {2 , 8 , 18 , 32 , 18, 3 , 0},
  {2 , 8 , 18 , 32 , 18, 4 , 0},
  {2 , 8 , 18 , 32 , 18, 5 , 0},
  {2 , 8 , 18 , 32 , 18, 6 , 0},
  {2 , 8 , 18 , 32 , 18, 7 , 0},
  {2 , 8 , 18 , 32 , 18, 8 , 0},
  {2 , 8 , 18 , 32 , 18, 8 , 1},
  {2 , 8 , 18 , 32 , 18, 8 , 2},
  {2 , 8 , 18 , 32 , 18, 9 , 2},
  {2 , 8 , 18 , 32 , 18, 10, 2},
  {2 , 8 , 18 , 32 , 20, 9 , 2},
  {2 , 8 , 18 , 32 , 21, 9 , 2},
  {2 , 8 , 18 , 32 , 22, 9 , 2},
  {2 , 8 , 18 , 32 , 24, 8 , 2},
  {2 , 8 , 18 , 32 , 25, 8 , 2},
  {2 , 8 , 18 , 32 , 25, 9 , 2},
  {2 , 8 , 18 , 32 , 27, 8 , 2},
  {2 , 8 , 18 , 32 , 28, 8 , 2},
  {2 , 8 , 18 , 32 , 29, 8 , 2},
  {2 , 8 , 18 , 32 , 30, 8 , 2},
  {2 , 8 , 18 , 32 , 31, 8 , 2},
  {2 , 8 , 18 , 32 , 32, 8 , 2},
  {2 , 8 , 18 , 32 , 32, 9 , 2},
  {2 , 8 , 18 , 32 , 32, 10, 2},
  {2 , 8 , 18 , 32 , 32, 11, 2},
  {0, 0, 0, 0, 0, 0, 0,},
  {0, 0, 0, 0, 0, 0, 0,},
  {0, 0, 0, 0, 0, 0, 0,}
};
//元素名称
const byte EN[354] PROGMEM = {72, 32, 32, 72, 101, 32, 76, 105, 32, 66, 101, 32, 66, 32, 32, 67, 32, 32, 78, 32, 32, 79, 32, 32, 70, 32, 32, 78, 101, 32, 78, 97, 32, 77, 103, 32, 65, 108, 32, 83, 105, 32, 80, 32, 32, 83, 32, 32, 67, 108, 32, 65, 114, 32, 75, 32, 32, 67, 97, 32, 83, 99, 32, 84, 105, 32, 86, 32, 32, 67, 114, 32, 77, 110, 32, 70, 101, 32, 67, 111, 32, 78, 105, 32, 67, 117, 32, 90, 110, 32, 71, 97, 32, 71, 101, 32, 65, 115, 32, 83, 101, 32, 66, 114, 32, 75, 114, 32, 82, 98, 32, 83, 114, 32, 89, 32, 32, 90, 114, 32, 78, 98, 32, 77, 111, 32, 84, 99, 33, 82, 117, 32, 82, 104, 32, 80, 100, 32, 65, 103, 32, 67, 100, 32, 73, 110, 32, 83, 110, 32, 83, 98, 32, 84, 101, 32, 73, 32, 32, 88, 101, 32, 67, 115, 32, 66, 97, 32, 76, 97, 32, 67, 101, 32, 80, 114, 32, 78, 100, 32, 80, 109, 32, 83, 109, 32, 69, 117, 32, 71, 100, 32, 84, 98, 32, 68, 121, 32, 72, 111, 32, 69, 114, 32, 84, 109, 32, 89, 98, 32, 76, 117, 32, 72, 102, 32, 84, 97, 32, 87, 32, 32, 82, 101, 32, 79, 115, 32, 73, 114, 32, 80, 116, 32, 65, 117, 32, 72, 103, 32, 84, 105, 32, 80, 98, 32, 66, 105, 32, 80, 111, 33, 65, 116, 33, 82, 110, 33, 70, 114, 33, 82, 97, 33, 65, 99, 33, 84, 104, 33, 80, 97, 33, 85, 32, 33, 78, 112, 33, 80, 117, 33, 65, 109, 33, 67, 109, 33, 66, 107, 33, 67, 102, 33, 69, 115, 33, 70, 109, 33, 77, 100, 33, 78, 111, 33, 76, 114, 33, 82, 102, 33, 68, 98, 33, 83, 103, 33, 66, 104, 33, 72, 115, 33, 77, 116, 33, 68, 115, 33, 82, 103, 33, 67, 110, 33, 78, 104, 33, 70, 108, 33, 77, 101, 33, 76, 118, 33, 84, 115, 33, 79, 103, 33,};
//族
const char Z_1[] PROGMEM = "IA";
const char Z_2[] PROGMEM = "IIA";
const char Z_3[] PROGMEM = "IIIB";
const char Z_4[] PROGMEM = "IVB";
const char Z_5[] PROGMEM = "VB";
const char Z_6[] PROGMEM = "VIB";
const char Z_7[] PROGMEM = "VIIB";
const char Z_8[] PROGMEM = "VIII";
const char Z_11[] PROGMEM = "IB";
const char Z_12[] PROGMEM = "IIB";
const char Z_13[] PROGMEM = "IIIA";
const char Z_14[] PROGMEM = "IVA";
const char Z_15[] PROGMEM = "VA";
const char Z_16[] PROGMEM = "VIA";
const char Z_17[] PROGMEM = "VIIA";
const char Z_18[] PROGMEM = "0";
const char* const Z_table[] PROGMEM = {Z_1, Z_2, Z_3, Z_4, Z_5, Z_6, Z_7, Z_8, Z_8, Z_8, Z_11, Z_12, Z_13, Z_14, Z_15, Z_16, Z_17, Z_18};
char Zbuffer[4];
unsigned long KeyTW; //按键冷却时间
#define KeyWTime 100 //每个按键间隔时间 单位ms
#define BZ 9
#define L1 131
#define L2 147
#define L3 165
#define L4 175
#define L5 196
#define L6 220
#define L7 247
#define M1 262
#define M2 294
#define M3 330
#define M4 349
#define M5 392
#define M6 440
#define M7 497
#define H1 523
#define H2 587
#define H3 659
#define H4 698
#define H5 784
#define H6 880
#define H7 988
byte PSP; //播放进度
byte PSS = 0; //播放曲目 255为禁用播放
unsigned long PST; //播放某个音符的时间
const int melody[] PROGMEM = {  //音符表
  M5, M5, M6, M2, M1, M1, L6, M2, M5, M5, M6, H1, M6, M5, M1, M1,
  L6, M2, M5, M2, M1, L7, L6, L5, M5, M2, M3, M2, M1, M1, L6, M2,
  M3, M2, M1, M2, M1, L7, L6, L5, L5, M5, M5, M6, M2, M1, M1, L6,
  M2, M5, M5, M6, H1, M6, M5, M1, M1, L6, M2, M5, M2, M1, L7, L6,
  L5, M5, M2, M3, M2, M1, M1, L6, M2, M3, M2, M1, M2, M1, L7, L6,
  L5, L5, M5, M5, M6, M2, M1, M1, L6, M2, M5, M5, M6, H1, M6, M5,
  M1, M1, L6, M2, M5, M2, M1, L7, L6, L5, M5, M2, M3, M2, M1, M1,
  L6, M2, M3, M2, M1, M2, M1, L7, L6, L5, L5, 0, M5, M2, M1, L7,
  L6, L5, M5, M2, M3, M2, M1, M1, L6, M2, M3, M2, M1, H2, H1, M7,
  M6, M5, M5
};
const uint8_t noteDurations[] PROGMEM = { //音符时长表
  1125, 562, 562, 2250, 1125, 562, 562, 2250, 1125, 1125, 562, 562, 562, 562, 1125, 562,
  562, 2250, 1125, 1125, 1125, 562, 562, 1125, 1125, 1125, 562, 562, 1125, 562, 562, 562,
  562, 562, 562, 562, 562, 562, 562, 1687, 1687, 1152, 562, 562, 2250, 1125, 562, 562,
  2250, 1125, 1125, 562, 562, 562, 562, 1125, 562, 562, 2250, 1125, 1125, 1125, 562, 562,
  1125, 1125, 1125, 562, 562, 1125, 562, 562, 562, 562, 562, 562, 562, 562, 562, 562,
  1728, 1728, 1125, 562, 562, 2250, 1125, 562, 562, 2250, 1125, 1125, 562, 562, 562, 562,
  1125, 562, 562, 2250, 1125, 1125, 1125, 562, 562, 1125, 1125, 1125, 562, 562, 1125, 562,
  562, 562, 562, 562, 562, 562, 562, 562, 562, 1728, 1728,
  1125, 1125, 1125, 1125, 562, 562, 1125, 1125, 1125, 562, 562, 1125, 562, 562, 562, 562,
  562, 562, 562, 562, 562, 562, 1728, 1728
};
bool PSD = false;
unsigned long PSDT; //某个间隔开始的时候
/*====================================================================
                             软重启函数
  ====================================================================*/
void(* resetFunc) (void) = 0; //制造重启命令
/*=========================================================
                     只循环一次
  =========================================================*/
void setup() {
  arduboy.boot();
  pinMode (BZ, OUTPUT);
  PSS = 255; //初始化音乐曲目
  //启动动画
  for (int i = 63; i >= 46; i--) {
    arduboy.clear();
    arduboy.drawSlowXYBitmap(26, i, HWT, 72, 8, 1);
    if (i == 46) arduboy.drawSlowXYBitmap(15, 9, title, 104, 17, 1);
    arduboy.display();
  }
  delay(1000);
}
/*=========================================================
                     不停循环
  =========================================================*/
void loop() {
  playsound();
  Key_scan();  //扫描按键
  /*=========================================================
                    显示
    =========================================================*/
  if (refresh == true) {
    arduboy.clear();
    DrawTable();  //表格
    Draw_bat();   //电池信息
    refresh = false;
    arduboy.display();
  }
}
/*=========================================================
                  渲染表格
  =========================================================*/
void DrawTable() {
  Nx = EX - 3;
  Ny = EY - 1;
  for (int y = 1; y <= 3; y++) {
    for (int x = 1; x <= 7; x++) {
      if (x == 4 && y == 2) {
        //处于选择位置 反色处理开始
        arduboy.fillRect(x * 16 - 1, y * 16 - 1, 17, 17, 1); //白色背景
        tinyfont.setTextColor(0);
      } else tinyfont.setTextColor(1);
      if (Nx >= 0 && Ny >= 0 && Nx <= 17 && Ny <= 9) {
        if (pgm_read_byte_near(&AM[Ny][Nx]) != 0) { //如果当前位置存在元素
          if (x == 4 && y == 2) {} else {
            arduboy.drawRect(x * 16 - 1, y * 16 - 1, 17, 17, 1); //画格子
          }
          tinyfont.setCursor(x * 16 + 1, y * 16); //在坐标开始画
          tinyfont.print(pgm_read_byte_near(&AM[Ny][Nx]));   //原子序号
          //元素名称
          tinyfont.setCursor(x * 16 + 1, y * 16 + 8); //在坐标开始画 第1个字符
          tinyfont.print((char)pgm_read_byte_near(&EN[(3 * pgm_read_byte_near(&AM[Ny][Nx])) - 3])); //元素名称
          tinyfont.setCursor(x * 16 + 1 + 5, y * 16 + 8); //在坐标开始画 第2个字符
          tinyfont.print((char)pgm_read_byte_near(&EN[(3 * pgm_read_byte_near(&AM[Ny][Nx])) - 2])); //元素名称
          tinyfont.setCursor(x * 16 + 1 + 5 + 5, y * 16 + 8); //在坐标开始画 第3个字符
          tinyfont.print((char)pgm_read_byte_near(&EN[(3 * pgm_read_byte_near(&AM[Ny][Nx])) - 1])); //元素名称
        } else {
          //判断是否为镧系和锕系
          if (Nx == 2 && Ny == 5) {
            if (x == 4 && y == 2) {} else {
              arduboy.drawRect(x * 16 - 1, y * 16 - 1, 17, 17, 1); //画格子
            }
            tinyfont.setCursor(x * 16 + 1, y * 16 + 5);  //在坐标开始画
            tinyfont.print("LaX");
          } else {
            if (Nx == 2 && Ny == 6) {
              if (x == 4 && y == 2) {

              } else {
                arduboy.drawRect(x * 16 - 1, y * 16 - 1, 17, 17, 1); //画格子
              }
              tinyfont.setCursor(x * 16 + 1, y * 16 + 5);  //在坐标开始画
              tinyfont.print("AcX");
            } else {
              //画背景
              arduboy.drawLine(x * 16 + 3, y * 16 + 3, x * 16 + 12, y * 16 + 12, 1);
              arduboy.drawLine(x * 16 + 12, y * 16 + 3, x * 16 + 3, y * 16 + 12, 1);
            }
          }
        }
      }
      Nx++;
    }
    //画周期
    if (Ny + 1 <= 7 && Ny + 1 > 0) {
      arduboy.setCursor(3, y * 16 + 3); //在坐标开始画
      arduboy.print(Ny + 1);
    }
    Nx = EX - 3;
    Ny++;
  }
  if (EY <= 7) { //在镧系和锕系关闭族的显示
    for (byte i = 0; i < 7; i++) {
      if (i + EX - 3 >= 0 && i + EX - 3 < 18) {
        if (((i + EX - 3) % 2) == 0) {
          tinyfont.setCursor(i * 16 + 16 + 4, 8);
          tinyfont.print(i + EX - 2);
          tinyfont.setCursor(i * 16 + 16, 0);
        } else {
          tinyfont.setCursor(i * 16 + 16 + 4, 0);
          tinyfont.print(i + EX - 2);
          tinyfont.setCursor(i * 16 + 16, 8);
        }
        strcpy_P(Zbuffer, (char*)pgm_read_word(&(Z_table[i + EX - 3])));
        tinyfont.print(Zbuffer);
      }
    }
  }
}
/*=========================================================
                  详细资料
  =========================================================*/
void show() {
  byte p = 1;
  while (!arduboy.pressed(B_BUTTON))
  {
    playsound();
    if (millis() >= KeyTW + KeyWTime) {
      KeyTW = millis();
      if (arduboy.pressed(LEFT_BUTTON)) {
        if (p > 1) {
          p--;
          refresh = true;
        }
      }
      if (arduboy.pressed(RIGHT_BUTTON)) {
        if (p < 3) {
          p++;
          refresh = true;
        }
      }
    }
    if (refresh == true) {
      TEIRN = 0;
      refresh = false;
      arduboy.clear();
      if (p == 1) {
        //资料页
        arduboy.setTextSize(2);
        arduboy.setCursor(60, 0);
        arduboy.print((char)pgm_read_byte_near(&EN[(3 * pgm_read_byte_near(&AM[EY][EX])) - 3])); //元素名称
        arduboy.setCursor(74, 0);
        arduboy.print((char)pgm_read_byte_near(&EN[(3 * pgm_read_byte_near(&AM[EY][EX])) - 2])); //元素名称
        arduboy.setCursor(92, 0);
        //是否放射性
        if (pgm_read_byte_near(&EN[(3 * pgm_read_byte_near(&AM[EY][EX])) - 1]) == 33) arduboy.drawSlowXYBitmap(112, 19, radiation, 16, 16, 1); //放射性图标
        //是否金属
        metal = true;
        for (int i = 0; i <= 23; i++) {
          if (pgm_read_byte_near(&non[i]) == pgm_read_byte_near(&AM[EY][EX])) {
            metal = false;
          }
        }
        if (metal == true) arduboy.drawSlowXYBitmap(112, 36, Bmrtal, 16, 16, 1); //金属图标
        arduboy.print(pgm_read_byte_near(&AM[EY][EX]));   //原子序数
        arduboy.setTextSize(1);
        arduboy.drawSlowXYBitmap(2, 1, Element, 56, 11, 1);
        arduboy.drawSlowXYBitmap(2, 21, Relative, 56, 11, 1);
        arduboy.drawSlowXYBitmap(1, 40, RM, 56, 12, 1);
        arduboy.setCursor(61, 22);
        if (pgm_read_byte_near(&AM[EY][EX]) < 108) {
          arduboy.print(float(pgm_read_byte_near(&Radius[pgm_read_byte_near(&AM[EY][EX]) - 1])) / 100); //半径
        } else {
          arduboy.print("?.???");
        }
        arduboy.setCursor(61, 44);
        if (pgm_read_byte_near(&AM[EY][EX]) <= 4) {
          arduboy.print(pgm_read_byte_near(&mass[2 * pgm_read_byte_near(&AM[EY][EX]) - 2]) / float(10) + pgm_read_byte_near(&mass[2 * pgm_read_byte_near(&AM[EY][EX]) - 1]) / float(1000), 3); //相对质量
        } else {
          if (pgm_read_byte_near(&AM[EY][EX]) <= 43) {
            arduboy.print(pgm_read_byte_near(&mass[2 * pgm_read_byte_near(&AM[EY][EX]) - 2]) + pgm_read_byte_near(&mass[2 * pgm_read_byte_near(&AM[EY][EX]) - 1]) / float(100), 2); //相对质量
          } else {
            arduboy.print(pgm_read_byte_near(&mass[2 * pgm_read_byte_near(&AM[EY][EX]) - 2]) * 10 + pgm_read_byte_near(&mass[2 * pgm_read_byte_near(&AM[EY][EX]) - 1]) / float(10), 1); //相对质量
          }
        }
        arduboy.drawLine(0, 35, 128, 35);
        arduboy.drawLine(0, 17, 128, 17);
      } else {
        if (p == 2) {
          //结构页
          //计算原子层数
          if (EY <= 7) {
            ZQ = EY;
          } else {
            if (EY == 8) {
              ZQ = 5;
            } else {
              if (EY == 9) {
                ZQ = 6;
              }
            }
          }
          //46号不规则
          if (pgm_read_byte_near(&AM[EY][EX]) == 46) ZQ = 3;
          arduboy.fillCircle(11, 30, 16, 1); //画实心圆
          for (int i = 1; i <= ZQ + 1; i++) {
            arduboy.drawCircle(11, 30, 12 + i * 15, 1);  //渲染运行轨道
          }
          //原子序数
          arduboy.setTextColor(BLACK);
          arduboy.setTextBackground(WHITE);
          arduboy.setCursor(0, 27);
          arduboy.print("+");
          arduboy.setCursor(8, 27);
          arduboy.print(pgm_read_byte_near(&AM[EY][EX]));
          arduboy.setTextColor(WHITE);
          arduboy.setTextBackground(BLACK);
          arduboy.fillRect(29, 26, 95, 13, 0); //清理轨道
          //标上电子数
          for (int i = 0; i <= ZQ; i++) {
            tinyfont.setCursor(39 + i * 14, 28);
            if (pgm_read_byte_near(&AM[EY][EX]) < 105) {
              tinyfont.print(pgm_read_byte_near(&AC[pgm_read_byte_near(&AM[EY][EX]) - 1][i]));
            } else {
              tinyfont.print(F("X"));
            }
          }
        } else {
          if (p == 3) {
            arduboy.setTextSize(2);
            arduboy.drawSlowXYBitmap(22, 1, VA, 88, 12, 1);
            arduboy.drawRect(0, 16, 128, 1, 1);
            arduboy.drawRect(64, 16, 1, 128, 1);
            arduboy.setCursor(16, 18);
            arduboy.print("Max");
            arduboy.setCursor(85, 18);
            arduboy.print("Min");
            arduboy.setCursor(27, 40);
            arduboy.print(pgm_read_byte_near(&AC[pgm_read_byte_near(&AM[EY][EX]) - 1][ZQ]));   //打印最外层电子
            arduboy.setCursor(95, 40);
            if (metal == true) {
              //金属没有负假
              arduboy.print("0");
            } else {
              if (pgm_read_byte_near(&AC[pgm_read_byte_near(&AM[EY][EX]) - 1][ZQ]) >= 4 && (pgm_read_byte_near(&AC[pgm_read_byte_near(&AM[EY][EX]) - 1][ZQ]) != 8)) {
                arduboy.print(8 - pgm_read_byte_near(&AC[pgm_read_byte_near(&AM[EY][EX]) - 1][ZQ]));
                arduboy.setCursor(80, 40);
                arduboy.print("-");
              } else {
                arduboy.print("0");
              }
            }
            arduboy.setTextSize(1);
          }
        }
      }
      arduboy.display();
    }
  }
  refresh = true;  //返回后进行画面刷新
}
/*=========================================================
                     电池电压
  =========================================================*/
long readVcc() {
  long result;
  // Read 1.1V reference against AVcc
  ADMUX = _BV(REFS0) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);
  delay(2); // Wait for Vref to settle
  ADCSRA |= _BV(ADSC); // Convert
  while (bit_is_set(ADCSRA, ADSC));
  result = ADCL;
  result |= ADCH << 8;
  result = 1126400L / result; // Back-calculate AVcc in mV
  return result;
}
void Draw_bat() {
  arduboy.fillRect(0, 0, 14, 14, 0); //背景
  float vcc_vol = readVcc() / 1000;            //将读取的vcc电压mv转换为v
  if (vcc_vol >= 4.5 ) {
    arduboy.drawSlowXYBitmap(1, 1, rook_bitmap5, 8, 8, 1);
  }
  if (vcc_vol < 4.5 && vcc_vol >= 4 ) {
    arduboy.drawSlowXYBitmap(1, 1, rook_bitmap4, 8, 8, 1);
  }
  if (vcc_vol < 4 && vcc_vol >= 3.5 ) {
    arduboy.drawSlowXYBitmap(1, 1, rook_bitmap3, 8, 8, 1);
  }
  if (vcc_vol < 3.5 && vcc_vol >= 3 ) {
    arduboy.drawSlowXYBitmap(1, 1, rook_bitmap2, 8, 8, 1);
  }
  if (vcc_vol < 3 ) {                //当VCC电压小于3v时图标闪烁，电池电量不足警告
    switch (flash) {
      case 0:
        arduboy.drawSlowXYBitmap(1, 1, rook_bitmap1, 8, 8, 1);
        flash = 1;
        break;
      case 1:
        arduboy.drawSlowXYBitmap(1, 1, rook_bitmap0, 8, 8, 1);
        flash = 0;
        break;
    }
  }
}
/*=========================================================
                    按键输入
    =========================================================*/
void Key_scan()
{
  if (millis() >= KeyTW + KeyWTime) {
    KeyTW = millis();
    if (arduboy.pressed(UP_BUTTON)) {
      if (EY > 0) {
        EY--;
        refresh = true;
      }
    }
    if (arduboy.pressed(DOWN_BUTTON)) {
      if (EY < 9) {
        EY++;
        refresh = true;
      }
    }
    if (arduboy.pressed(LEFT_BUTTON)) {
      if (EX > 0) {
        EX--;
        refresh = true;
      }
    }
    if (arduboy.pressed(RIGHT_BUTTON)) {
      if (EX < 17) {
        EX++;
        refresh = true;
      }
    }
    
    if (arduboy.pressed(A_BUTTON)) {
      if (pgm_read_byte_near(&AM[EY][EX]) != 0) {
        refresh = true;
        show();
      } else {
        if (EX == 2 && EY == 5) {
          EX = 1;
          EY = 8;
          refresh = true;
        }
        if (EX == 2 && EY == 6) {
          EX = 1;
          EY = 9;
          refresh = true;
        }
        delay(200); //防止按键短时间触发两遍
      }
    }
  }
}
/*=========================================================
                   声音播放器
  =========================================================*/
void playsound() {
  if (arduboy.pressed(A_BUTTON)&&arduboy.pressed(B_BUTTON)) {
        switch (PSS) {
          case 0:
            PSS = 255;
            break;
          case 255:
            PSS = 0;
        }
        delay(2000);
      }
  //检测播放地址是否合法
  if (PSS != 255) {  //如果曲目是255 *注意PSS=255时关闭音乐
    if (PSS == 0) {  //曲目1 东方红
      if (PSP >= 148) {  //检测到播放位置溢出 重置位置到曲目开头
        PSP = 0;  //设置当前曲目在音符表的开始地址
        PST = millis() / 10.0; //记录开始播放该位置音符的时间
      }
    }
    if (pgm_read_word_near(&melody[PSP]) != 0 && PSD == false) {
      tone(BZ, pgm_read_word_near(&melody[PSP]));
    } else {
      noTone(BZ); //禁用
    }
    //检测是否播放完一个音节
    if (millis() / 10.0 >= PST + (pgm_read_byte_near(&noteDurations[PSP]))) {
      //该PSP位置音符播放完毕，加地址
      if (PSD == false) {
        //播放完音符
        PSD = true;
        PSDT = millis();
      } else if (millis() >= PSDT + 15) { //间隔单位ms
        //如果超过间隔的时间间隔完成
        PSD = false;
        PSP++; //音乐播放位置加一
        PST = millis() / 10.0; //重置播放音符时间
      }
    }
  } else noTone(BZ); //禁用
}
